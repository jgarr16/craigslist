<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Craigslist-ish Gallery</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/png" href="my-favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="my-favicon/favicon.svg" />
    <link rel="shortcut icon" href="my-favicon/favicon.ico" />
    <!-- Apple Touch Icons - iOS will use the largest appropriate size -->
    <!-- Order matters: list larger sizes first for better quality on Retina displays -->
    <link rel="apple-touch-icon" sizes="512x512" href="my-favicon/web-app-manifest-512x512.png" />
    <link rel="apple-touch-icon" sizes="192x192" href="my-favicon/web-app-manifest-192x192.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="my-favicon/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="Craigslist-ish" />
    <link rel="manifest" href="my-favicon/site.webmanifest" />

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
</head>
<body>
    <header>
        <h1>Craigslist-ish</h1>
    </header>

    <main>
        <div class="filter-buttons">
            <!-- Buttons will be dynamically generated -->
        </div>

        <div class="want-toggle" style="display: none;">
            <div class="want-toggle-label">Mark this item:</div>
            <div class="want-toggle-buttons">
                <button class="want-toggle-btn" data-status="new">NEW</button>
                <button class="want-toggle-btn" data-status="want">✓ Want</button>
                <button class="want-toggle-btn" data-status="dont-want">✗ Don't Want</button>
                <button class="want-toggle-btn" data-status="undecided">Clear</button>
            </div>
        </div>

        <div class="notes-section" style="display: none;">
            <div class="notes-container">
                <h2 class="notes-title"></h2>
                <div class="notes-controls">
                    <button class="notes-edit-btn">Edit Notes</button>
                    <button class="notes-save-btn" style="display: none;">Save</button>
                    <button class="notes-cancel-btn" style="display: none;">Cancel</button>
                </div>
                <div class="notes-display"></div>
                <textarea class="notes-textarea" style="display: none;" placeholder="Add notes about this category..."></textarea>
            </div>
        </div>

        <div class="gallery">
            <!-- Gallery items will be dynamically generated from gallery-data.json -->
        </div>
    </main>

    <footer>
        <p>&copy; <span id="copyright-year"></span> Craigslist-ish Gallery</p>
    </footer>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBRY7IXl_WpYyP9b19HT2Dq_qgV3T_e6k4",
            authDomain: "craigslist-gallery.firebaseapp.com",
            databaseURL: "https://craigslist-gallery-default-rtdb.firebaseio.com",
            projectId: "craigslist-gallery",
            storageBucket: "craigslist-gallery.firebasestorage.app",
            messagingSenderId: "1054501050420",
            appId: "1:1054501050420:web:8cb8c243ae86eadf72d261"
        };

        // Initialize Firebase
        let database;
        try {
            firebase.initializeApp(firebaseConfig);
            database = firebase.database();
        } catch (error) {
            console.error('Firebase initialization error:', error);
            // Continue without Firebase functionality
            database = null;
        }

        // Load gallery data and dynamically generate everything
        const galleryContainer = document.querySelector('.gallery');
        const filterButtonsContainer = document.querySelector('.filter-buttons');
        let allGalleryItems = [];

        // Notes functionality
        const notesSection = document.querySelector('.notes-section');
        const notesTitle = document.querySelector('.notes-title');
        const notesDisplay = document.querySelector('.notes-display');
        const notesTextarea = document.querySelector('.notes-textarea');
        const notesEditBtn = document.querySelector('.notes-edit-btn');
        const notesSaveBtn = document.querySelector('.notes-save-btn');
        const notesCancelBtn = document.querySelector('.notes-cancel-btn');
        let categoryNotes = {};
        let currentCategory = null;

        // Want/Don't Want functionality
        const wantToggle = document.querySelector('.want-toggle');
        const wantToggleButtons = document.querySelectorAll('.want-toggle-btn');
        let categoryWantStatus = {};

        // Load notes from Firebase
        const loadNotes = () => {
            if (!database) {
                console.warn('Firebase not initialized. Notes will not be saved.');
                return;
            }
            database.ref('categoryNotes').on('value', (snapshot) => {
                try {
                    categoryNotes = snapshot.val() || {};
                    // Refresh the current category display if one is selected
                    if (currentCategory && currentCategory !== 'all') {
                        displayNotes(currentCategory);
                    }
                } catch (error) {
                    console.error('Error loading notes:', error);
                    categoryNotes = {};
                }
            }, (error) => {
                console.error('Firebase error loading notes:', error);
                categoryNotes = {};
            });
        };

        // Save notes to Firebase
        const saveNotes = () => {
            if (!database) {
                console.warn('Firebase not initialized. Notes will not be saved.');
                return;
            }
            try {
                database.ref('categoryNotes').set(categoryNotes);
            } catch (error) {
                console.error('Error saving notes:', error);
            }
        };

        // Load want status from Firebase
        const loadWantStatus = () => {
            if (!database) {
                console.warn('Firebase not initialized. Want status will not be saved.');
                return;
            }
            database.ref('categoryWantStatus').on('value', (snapshot) => {
                try {
                    categoryWantStatus = snapshot.val() || {};
                    updateAllWantIndicators();
                    if (currentCategory && currentCategory !== 'all') {
                        updateWantToggle(currentCategory);
                    }
                } catch (error) {
                    console.error('Error loading want status:', error);
                    categoryWantStatus = {};
                }
            }, (error) => {
                console.error('Firebase error loading want status:', error);
                categoryWantStatus = {};
            });
        };

        // Save want status to Firebase
        const saveWantStatus = () => {
            if (!database) {
                console.warn('Firebase not initialized. Want status will not be saved.');
                return;
            }
            try {
                database.ref('categoryWantStatus').set(categoryWantStatus);
            } catch (error) {
                console.error('Error saving want status:', error);
            }
        };

        // Update want indicators on all gallery items
        const updateAllWantIndicators = () => {
            allGalleryItems.forEach(item => {
                const category = item.getAttribute('data-category');
                const status = categoryWantStatus[category];

                // Remove existing indicator
                const existingIndicator = item.querySelector('.want-indicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                }

                // Add indicator based on status
                if (status === 'new') {
                    const indicator = document.createElement('div');
                    indicator.className = 'want-indicator new';
                    indicator.textContent = 'NEW';
                    indicator.style.display = currentCategory === 'all' ? 'flex' : 'none';
                    item.appendChild(indicator);
                } else if (status === 'want') {
                    const indicator = document.createElement('div');
                    indicator.className = 'want-indicator want';
                    indicator.textContent = '✓';
                    indicator.style.display = currentCategory === 'all' ? 'flex' : 'none';
                    item.appendChild(indicator);
                } else if (status === 'dont-want') {
                    const indicator = document.createElement('div');
                    indicator.className = 'want-indicator dont-want';
                    indicator.textContent = '✗';
                    indicator.style.display = currentCategory === 'all' ? 'flex' : 'none';
                    item.appendChild(indicator);
                }
            });

            // Update button indicators
            updateButtonIndicators();
        };

        // Update want indicators on filter buttons
        const updateButtonIndicators = () => {
            const filterButtons = document.querySelectorAll('.filter-btn');
            filterButtons.forEach(btn => {
                const category = btn.getAttribute('data-filter');
                if (category === 'all') return; // Skip the "All" button

                const indicator = btn.querySelector('.btn-indicator');
                if (indicator) {
                    const status = categoryWantStatus[category];

                    if (status === 'new') {
                        indicator.textContent = 'NEW';
                        indicator.className = 'btn-indicator new';
                    } else if (status === 'want') {
                        indicator.textContent = '✓';
                        indicator.className = 'btn-indicator want';
                    } else if (status === 'dont-want') {
                        indicator.textContent = '✗';
                        indicator.className = 'btn-indicator dont-want';
                    } else {
                        indicator.textContent = '';
                        indicator.className = 'btn-indicator';
                    }
                }
            });
        };

        // Update want toggle buttons
        const updateWantToggle = (category) => {
            const status = categoryWantStatus[category] || 'undecided';
            wantToggleButtons.forEach(btn => {
                const btnStatus = btn.getAttribute('data-status');
                if (btnStatus === status) {
                    btn.classList.add('active', status);
                } else {
                    btn.classList.remove('active', 'want', 'dont-want', 'undecided', 'new');
                }
            });
        };

        // Handle want toggle button clicks
        wantToggleButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const status = btn.getAttribute('data-status');
                if (currentCategory && currentCategory !== 'all') {
                    if (status === 'undecided') {
                        delete categoryWantStatus[currentCategory];
                    } else {
                        categoryWantStatus[currentCategory] = status;
                    }
                    saveWantStatus();
                    updateWantToggle(currentCategory);
                    updateAllWantIndicators();
                }
            });
        });

        // Escape HTML to prevent XSS attacks
        const escapeHtml = (text) => {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        };

        // Safely render notes with line breaks
        const renderNotes = (container, text) => {
            container.innerHTML = ''; // Clear container
            if (!text || text.trim() === '') {
                const em = document.createElement('em');
                em.textContent = 'No notes yet. Click "Edit Notes" to add some.';
                container.appendChild(em);
            } else {
                // Split by newlines and create text nodes with br elements
                const lines = text.split('\n');
                lines.forEach((line, index) => {
                    if (index > 0) {
                        container.appendChild(document.createElement('br'));
                    }
                    const textNode = document.createTextNode(line);
                    container.appendChild(textNode);
                });
            }
        };

        // Display notes for current category
        const displayNotes = (category) => {
            currentCategory = category;
            if (category === 'all') {
                notesSection.style.display = 'none';
                return;
            }

            notesSection.style.display = 'block';
            const displayName = category.split('_').map(word =>
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
            notesTitle.textContent = `${displayName} Notes`;

            const notes = categoryNotes[category] || '';
            renderNotes(notesDisplay, notes);
            notesDisplay.style.display = 'block';
            notesTextarea.style.display = 'none';
            notesEditBtn.style.display = 'inline-block';
            notesSaveBtn.style.display = 'none';
            notesCancelBtn.style.display = 'none';
        };

        // Edit notes
        notesEditBtn.addEventListener('click', () => {
            const notes = categoryNotes[currentCategory] || '';
            notesTextarea.value = notes;
            notesDisplay.style.display = 'none';
            notesTextarea.style.display = 'block';
            notesEditBtn.style.display = 'none';
            notesSaveBtn.style.display = 'inline-block';
            notesCancelBtn.style.display = 'inline-block';
            notesTextarea.focus();
        });

        // Save notes
        notesSaveBtn.addEventListener('click', () => {
            categoryNotes[currentCategory] = notesTextarea.value;
            saveNotes();
            displayNotes(currentCategory);
        });

        // Cancel edit
        notesCancelBtn.addEventListener('click', () => {
            displayNotes(currentCategory);
        });

        // Load notes and want status on startup
        loadNotes();
        loadWantStatus();

        // Set copyright year
        document.getElementById('copyright-year').textContent = new Date().getFullYear();

        // Fetch gallery data
        fetch(`gallery-data.json`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(galleryData => {
                // Generate gallery items
                galleryData.forEach(item => {
                    const galleryItem = document.createElement('div');
                    galleryItem.className = 'gallery-item show';
                    galleryItem.setAttribute('data-category', item.category);
                    galleryItem.setAttribute('data-number', item.number);

                    const img = document.createElement('img');
                    img.src = `images/${item.filename}`;
                    img.alt = item.alt;
                    img.loading = 'lazy'; // Enable lazy loading

                    galleryItem.appendChild(img);

                    // Add category overlay (will only be visible in "all" view)
                    const overlay = document.createElement('div');
                    overlay.className = 'category-overlay';
                    const displayName = item.category.split('_').map(word =>
                        word.charAt(0).toUpperCase() + word.slice(1)
                    ).join(' ');
                    overlay.textContent = displayName;
                    galleryItem.appendChild(overlay);

                    galleryContainer.appendChild(galleryItem);
                });

                allGalleryItems = document.querySelectorAll('.gallery-item');

                // Get unique categories
                const categories = new Set();
                galleryData.forEach(item => {
                    categories.add(item.category);
                });

                // Create "All" button
                const allButton = document.createElement('button');
                allButton.className = 'filter-btn active';
                allButton.setAttribute('data-filter', 'all');
                allButton.textContent = 'All';
                filterButtonsContainer.appendChild(allButton);

                // Create buttons for each category
                categories.forEach(category => {
                    const button = document.createElement('button');
                    button.className = 'filter-btn';
                    button.setAttribute('data-filter', category);

                    // Add indicator span
                    const indicator = document.createElement('span');
                    indicator.className = 'btn-indicator';
                    button.appendChild(indicator);

                    // Add text node
                    const text = document.createTextNode(category.split('_').map(word =>
                        word.charAt(0).toUpperCase() + word.slice(1)
                    ).join(' '));
                    button.appendChild(text);

                    filterButtonsContainer.appendChild(button);
                });

                // Set up filter functionality
                const filterButtons = document.querySelectorAll('.filter-btn');

                const applyFilter = (filterValue, updateUrl = true) => {
                    // Update active button
                    filterButtons.forEach(btn => {
                        if (btn.getAttribute('data-filter') === filterValue) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });

                    // Filter gallery items
                    allGalleryItems.forEach(item => {
                        const category = item.getAttribute('data-category');
                        const number = item.getAttribute('data-number');
                        const overlay = item.querySelector('.category-overlay');
                        const indicator = item.querySelector('.want-indicator');

                        if (filterValue === 'all') {
                            // Only show first image of each category
                            if (number === '1') {
                                item.style.display = 'block';
                                setTimeout(() => item.classList.add('show'), 10);
                                if (overlay) overlay.style.display = 'block';
                                if (indicator) indicator.style.display = 'flex';
                            } else {
                                item.classList.remove('show');
                                setTimeout(() => item.style.display = 'none', 300);
                            }
                        } else if (category === filterValue) {
                            item.style.display = 'block';
                            setTimeout(() => item.classList.add('show'), 10);
                            if (overlay) overlay.style.display = 'none';
                            if (indicator) indicator.style.display = 'none';
                        } else {
                            item.classList.remove('show');
                            setTimeout(() => item.style.display = 'none', 300);
                        }
                    });

                    // Show/hide want toggle
                    if (filterValue === 'all') {
                        wantToggle.style.display = 'none';
                    } else {
                        wantToggle.style.display = 'flex';
                        updateWantToggle(filterValue);
                    }

                    // Update URL hash for shareable links
                    if (updateUrl) {
                        if (filterValue === 'all') {
                            history.pushState(null, null, '#all');
                        } else {
                            history.pushState(null, null, `#${filterValue}`);
                        }
                    }

                    // Display notes for the selected category
                    displayNotes(filterValue);

                    // Scroll to top smoothly
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                };

                filterButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const filterValue = button.getAttribute('data-filter');
                        applyFilter(filterValue);
                    });
                });

                // Make gallery items clickable to filter by category
                allGalleryItems.forEach(item => {
                    item.addEventListener('click', () => {
                        const category = item.getAttribute('data-category');
                        applyFilter(category);
                    });
                });

                // Handle browser back/forward buttons
                window.addEventListener('hashchange', () => {
                    const hash = window.location.hash.substring(1); // Remove the #
                    const filterValue = hash || 'all';
                    applyFilter(filterValue, false); // Don't update URL since we're responding to URL change
                });

                // Apply filter based on URL hash on page load
                const initialHash = window.location.hash.substring(1);
                if (initialHash && initialHash !== 'all') {
                    // Check if the hash matches a valid category
                    const validCategories = Array.from(categories);
                    if (validCategories.includes(initialHash)) {
                        applyFilter(initialHash, false);
                    } else {
                        applyFilter('all', false);
                    }
                } else {
                    applyFilter('all', false);
                }
            })
            .catch(error => {
                console.error('Error loading gallery data:', error);
                galleryContainer.innerHTML = '<p style="text-align: center; padding: 2rem; color: #ef4444;">Error loading gallery. Please check your connection and ensure gallery-data.json exists. If the problem persists, run generate-gallery.js script.</p>';
            });
    </script>
</body>
</html>
